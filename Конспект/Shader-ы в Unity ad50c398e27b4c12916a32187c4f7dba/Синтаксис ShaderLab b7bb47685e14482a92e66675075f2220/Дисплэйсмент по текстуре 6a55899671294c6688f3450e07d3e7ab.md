# Дисплэйсмент по текстуре

Карта дисплэйсмента — карта, которая в оттенках черного и белого показывает, какие места являются рельефными, а какие не рельефными. Белые участки будут говорить о том, что участок текстуры нужно выдавить, а черные, наоборот, о том, что текстуру в этом участке не надо изменять. Использовать эту карту мы можем только шейдерной модели 3.0. До этого момента мы либо не указывали требуемое значение шейдерной модели, либо не объясняли. Указав шейдерную модель, мы явно дали понять unity какие инструкции должны присутствовать на устройстве, на котором запускается игра. Модель шейдера указывается следующим образом:

```c
#pragma target 3.0
```

Теперь приступим к реализации Дисплэйсмента по текстуре:

```c
Shader "ShaderLessions/DisplacementShader"
{
    Properties
    {
        _Color ("Color", Color) = (1,1,1,1)
        _MainTex ("Albedo (RGB)", 2D) = "white" {}
        _Extrude ("Extrude", Float) = 0.0
        _DispMap ("Dispalcement Map", 2D) = "black" {} // Задаем карту искажения
    }
    SubShader
    {
        Tags
        {
            "RenderType"="Opaque"
        }
        LOD 200

        CGPROGRAM
        #pragma surface surf Standard [vertex:vert](#pragma,%20%D0%BF%D0%B0%D1%81%D1%81%D1%8B,%20%D1%81%D0%B3%D0%B5%D0%BD%D0%B5%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B8%CC%86%20%D1%88%D0%B5%D0%B8%CC%86%D0%B4%D0%B5%D1%80%2089f7f336a87748a786e465bf5eeade49.md)  // Добавляем в шейдер вертексный
[](#pragma,%20%D0%BF%D0%B0%D1%81%D1%81%D1%8B,%20%D1%81%D0%B3%D0%B5%D0%BD%D0%B5%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%BD%D1%8B%D0%B8%CC%86%20%D1%88%D0%B5%D0%B8%CC%86%D0%B4%D0%B5%D1%80%2089f7f336a87748a786e465bf5eeade49.md)
        #pragma target 3.0

        sampler2D _MainTex,
                  _DispMap;
        fixed4 _Color;
        float _Extrude;

        struct Input
        {
            float2 uv_MainTex;
        };

        void vert(inout appdata_full v, out Input o)
        {
            UNITY_INITIALIZE_OUTPUT(Input, o);
            v.vertex.xyz += v.normal * _Extrude * tex2Dlod(_DispMap, float4(v.texcoord.xy, 0.0, 0.0)).r; 
        }

        void surf(Input IN, inout SurfaceOutputStandard o)
        {
            fixed4 c = tex2D(_MainTex, IN.uv_MainTex) * _Color;
            o.Albedo = c.rgb;
            o.Alpha = c.a;
        }
        ENDCG
    }
    FallBack "Diffuse"
}
```

![Untitled](%D0%94%D0%B8%D1%81%D0%BF%D0%BB%D1%8D%D0%B8%CC%86%D1%81%D0%BC%D0%B5%D0%BD%D1%82%20%D0%BF%D0%BE%20%D1%82%D0%B5%D0%BA%D1%81%D1%82%D1%83%D1%80%D0%B5%206a55899671294c6688f3450e07d3e7ab/Untitled.png)

![Untitled](%D0%94%D0%B8%D1%81%D0%BF%D0%BB%D1%8D%D0%B8%CC%86%D1%81%D0%BC%D0%B5%D0%BD%D1%82%20%D0%BF%D0%BE%20%D1%82%D0%B5%D0%BA%D1%81%D1%82%D1%83%D1%80%D0%B5%206a55899671294c6688f3450e07d3e7ab/Untitled%201.png)

Дисплэйсмент по текстуре происходит в вертексном шейдере, а потому в нем могут быть недоступны некоторые функции и параметры из фрагментного(surface-ного). Но по большей части у функций будет просто другое название. Так, вместо `tex2D` в вертексном шейдере нужно использовать `tex2Dlod`, чтобы подгрузить карту искажения. Эта функция принимает карту и `uv` координаты. Однако тут есть проблема: До этого `uv` координаты мы брали из входного параметра `IN`, но теперь мы сами его должны создавать и в этой функции(`vert`) его быть не может. Тут придется воспользоваться входящим параметром `appdata_full.texcoord`. Обрати внимание, в нём не учитывается `Tiling` и `Offset`, а потому нужно будет самому их просчитывать. Но для упрощенного случая, когда эти параметры не меняются, можно просто оставить всё как есть и использовать эту текстуру. Но ведь мы не просто передаем эту текстуру, а ещё зачем то создаем 4-х мерную текстуру. Вызвано это тем, что второй входной параметр это `float4`, где в качестве `w` выступает `mipmap` — параметр, отвечающий какого качества текстуры нужно отображать на экране. Чем дальше камера от текстуры, тем больше будет `mipmap`, дабы сэкономить ресурсы. Установим его пока `0.0` — самая качественная текстура. Далее мы берём от результата функции `tex2Dlod` только `r` компоненту. Ну тут это вызвано из-за самой текстуры(У меня не было подходящей, потому использовал то, что попалось).